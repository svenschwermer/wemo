/***************************************************************************
*
* Created by Belkin International, Software Engineering on XX/XX/XX.
* Copyright (c) 2014 Belkin International, Inc. and/or its affiliates. All
* rights reserved.
*
* Belkin International, Inc. retains all right, title and interest (including
* all intellectual property rights) in and to this computer program, which is
* protected by applicable intellectual property laws.  Unless you have obtained
* a separate written license from Belkin International, Inc., you are not
* authorized to utilize all or a part of this computer program for any purpose
* (including reproduction, distribution, modification, and compilation into
* object code) and you must immediately destroy or return to Belkin
* International, Inc all copies of this computer program.  If you are licensed
* by Belkin International, Inc., your rights to utilize this computer program
* are limited by the terms of that license.
*
* To obtain a license, please contact Belkin International, Inc.
*
* This computer program contains trade secrets owned by Belkin International,
* Inc.  and, unless unauthorized by Belkin International, Inc. in writing, you
* agree to maintain the confidentiality of this computer program and related
* information and to not disclose this computer program and related information
* to any other person or entity.
*
* THIS COMPUTER PROGRAM IS PROVIDED AS IS WITHOUT ANY WARRANTIES, AND BELKIN
* INTERNATIONAL, INC.  EXPRESSLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
* INCLUDING THE WARRANTIES OF MERCHANTIBILITY, FITNESS FOR A PARTICULAR
* PURPOSE, TITLE, AND NON-INFRINGEMENT.
*
***************************************************************************/
#ifdef __MIPSEL__

#define _GNU_SOURCE		/* for strcasestr */

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <mtd/mtd-user.h>
#include <unistd.h>
#include <belkin_diag.h>  /* Run-time diagnostics.  Keep as last include. */

#define RANDOM_DATA  "/dev/urandom" /* Non-blocking, but good enough */

#define SIGNATURE_OFFSET	0x00
#define RA0_OFFSET		0x04
#define GMAC0_OFFSET		0x28
#define GMAC1_OFFSET		0x2e

#define MIN(a, b) ((a) < (b) ? (a) : (b)) 

/* Binary data extracted from Gemtek file
 * romfs/etc_ro/wlan/RT5350_AP_1T1R_V0_0.bin
 */
static char factory_data[] = {
	0x50, 0x53, 0x00, 0x01, 0x00, 0x0c, 0x43, 0x30, /* 0x000 */
	0x50, 0x58, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x020 */
	0x00, 0x0c, 0x43, 0x30, 0x50, 0x77, 0x00, 0x0c,
	0x43, 0x30, 0x50, 0x66, 0x11, 0xff, 0x24, 0x10,
	0xff, 0xff, 0x2b, 0x01, 0x55, 0x77, 0xa8, 0xaa,
	0x8c, 0x88, 0xff, 0xff, 0x0c, 0x00, 0x00, 0x00, /* 0x040 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xff, 0xff, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x060 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x080 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x0a0 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x0c0 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x66,
	0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, /* 0x0e0 */
	0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x100 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x81, 0x09, 0x1c, 0x13, 0x4f, 0x15, 0x4f, 0x15, /* 0x120 */
	0x03, 0x1d, 0x07, 0x1d, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x140 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x160 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x180 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x1a0 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x1c0 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 0x1e0 */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

static char *find_mtd_device(char *block_name, size_t size, size_t *erase_size,
			     const char *name)
{
	FILE *fp;
	char buffer[128];

	if (!block_name || !size)
		return NULL;
	block_name[0] = 0;
	fp = fopen("/proc/mtd","r");
	if (fp == NULL) {
		fprintf(stderr,"fopen(/proc/mtd) failed: %s\n",
			strerror(errno));
		return NULL;
	}

	while (fgets(buffer, sizeof(buffer), fp) != NULL) {
		const char *delim = ": ";
		char *raw_name;
		char *part_size;
		char *erase;
		char *part_name;
		char *saveptr = NULL;

		raw_name = strtok_r(buffer, delim, &saveptr);
		part_size = !raw_name ? NULL : strtok_r(NULL, delim, &saveptr);
		erase = !part_size ? NULL : strtok_r(NULL, delim, &saveptr);
		part_name = !erase ? NULL : strtok_r(NULL, delim, &saveptr);
		if (part_name &&
		    strcasestr(part_name, name) != NULL) {
			*erase_size = strtol(erase + strspn(erase, "0"), NULL,
					     16);
			snprintf(block_name, size, "/dev/%s", raw_name);
			fclose(fp);
			return block_name;
		}
	}
	fclose(fp);
	return NULL;
}

static void factory_write(const char *mtd_name, int fd,
			  void *buffer, size_t erase_size)
{
	struct erase_info_user erase;
	int rc;

	erase.start = 0;
	erase.length = erase_size;
	rc = ioctl(fd, MEMUNLOCK, &erase);
	if (rc < 0)
		fprintf(stderr, "Unlock failed for %s: %s\n",
			mtd_name, strerror(errno));
	rc = ioctl(fd, MEMERASE, &erase);
	if (rc < 0) {
		fprintf(stderr, "MTD erase error on %s: %s\n",
			mtd_name, strerror(errno));
		return;
	}
	rc = write(fd, buffer, erase_size);
	if (rc != erase_size) {
		if (rc == 0)
			fprintf(stderr, "EOF on write to %s\n", mtd_name);
		else if (rc < 0)
			fprintf(stderr, "Error on write to %s: %s\n",
				mtd_name, strerror(errno));
		else
			fprintf(stderr, "Truncated write of %s, requested %d, "
				"transferred %d\n",
				mtd_name, erase_size, rc);
	}
	rc = ioctl (fd, MEMLOCK, &erase);
	if (rc < 0)
		fprintf(stderr, "Lock failed for %s: %s\n",
			mtd_name, strerror(errno));
}

				/* zap three bytes of memory with random data */
static void zap3(char *buffer)
{
	int fd = open(RANDOM_DATA, O_RDONLY);
	int n;

	if (fd < 0)
		perror("Cannot open " RANDOM_DATA);
	else {
		n = read(fd, buffer, 3);
		if (n < 0)
			perror("Error reading " RANDOM_DATA);
		else if (n == 0)
			fprintf(stderr, "EOF reading " RANDOM_DATA "\n");
		else if (n != 3)
			fprintf(stderr, "Truncated read of " RANDOM_DATA
				": %d bytes returned\n", n);
		close(fd);
	}
}

void restoreFactory(void)
{
	char mtd_name[64];
	size_t erase_size = 0;
	char *buffer;
	int fd, n;

	if (!find_mtd_device(mtd_name, sizeof(mtd_name), &erase_size,
			     "\"Factory\"")) {
		fprintf(stderr, "Cannot find \"Factory\" mtd partition\n");
		return;
	}
	fd = open(mtd_name, O_RDONLY);
	if (fd < 0) {
		fprintf(stderr, "Cannot open %s: %s\n",
			mtd_name, strerror(errno));
		return;
	}
	buffer = malloc(erase_size);
	if (!buffer) {
		fprintf(stderr, "Cannot allocate %d byte buffer for %s contents\n",
			erase_size, mtd_name);
		goto fail;
	}
	memset(buffer, 0, erase_size);
	n = read(fd, buffer, erase_size);
	if (n != erase_size) {
		if (n == 0)
			fprintf(stderr, "EOF on %s read\n", mtd_name);
		else
			fprintf(stderr, "Truncate read for %s, asked %d, received %d\n",
				mtd_name, erase_size, n);
		goto fail;
	}
	if (memcmp(buffer + SIGNATURE_OFFSET, factory_data + SIGNATURE_OFFSET,
		   3) == 0 &&
	    memcmp(buffer + RA0_OFFSET, factory_data + RA0_OFFSET, 3) == 0 &&
	    memcmp(buffer + GMAC0_OFFSET, factory_data + GMAC0_OFFSET, 3) == 0 &&
	    memcmp(buffer + GMAC1_OFFSET, factory_data + GMAC1_OFFSET, 3) == 0) {
		fprintf(stderr, "Partition %s doesn't look corrupted\n",
			mtd_name);
		fprintf(stderr, "To force a factory partition rewrite, "
			"\"mtd erase %s\", then rerun\n"
			"\"nvram factory\"\n", mtd_name);
	}
	close(fd);

	memcpy(buffer, factory_data, MIN(erase_size, sizeof(factory_data)));
	zap3(buffer + RA0_OFFSET + 3);
	zap3(buffer + GMAC0_OFFSET + 3);
	zap3(buffer + GMAC1_OFFSET + 3);
	buffer[RA0_OFFSET + 5] &= ~1; /* RA0 MAC address must be even */
	fd = open(mtd_name, O_RDWR);
	if (fd < 0) {
		fprintf(stderr, "Cannot reopen %s for update: %s\n",
			mtd_name, strerror(errno));
		return;
	}
	factory_write(mtd_name, fd, buffer, erase_size);

fail:
	close(fd);
}

#endif   // __MIPSEL__

